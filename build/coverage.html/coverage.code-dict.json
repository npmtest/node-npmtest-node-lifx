{"/home/travis/build/npmtest/node-npmtest-node-lifx/test.js":"/* istanbul instrument in package npmtest_node_lifx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-lifx/lib.npmtest_node_lifx.js":"/* istanbul instrument in package npmtest_node_lifx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_lifx = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_lifx = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-lifx/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-lifx && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_lifx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_lifx\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_lifx.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_node_lifx.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_lifx.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_node_lifx.__dirname +\n                    '/lib.npmtest_node_lifx.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx.js":"var lifx = exports;\n\n// Export constants\nlifx.constants = require('./lifx/constants');\n\n// Export utils\nlifx.utils = require('./lifx/utils');\n\n// Export packet parser\nlifx.packet = require('./lifx/packet');\n\n// Export light device object\nlifx.Light = require('./lifx/light').Light;\n\n// Export client\nlifx.Client = require('./lifx/client').Client;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/constants.js":"'use strict';\n\nmodule.exports = {\n  // Ports used by LIFX\n  LIFX_DEFAULT_PORT: 56700,\n  LIFX_ANY_PORT: 56800,\n\n  // Masks for packet description in packet header\n  ADDRESSABLE_BIT: 0x1000,\n  TAGGED_BIT: 0x2000,\n  ORIGIN_BITS: 0xC000,\n  PROTOCOL_VERSION_BITS: 0xFFF,\n\n  // Masks for response types in packet header\n  RESPONSE_REQUIRED_BIT: 0x1,\n  ACK_REQUIRED_BIT: 0x2,\n\n  // Protocol version mappings\n  PROTOCOL_VERSION_CURRENT: 1024,\n  PROTOCOL_VERSION_1: 1024,\n\n  MESSAGE_RATE_LIMIT: 50, // in ms\n  DISCOVERY_INTERVAL: 5000, // in ms\n\n  // Packet headers\n  PACKET_HEADER_SIZE: 36,\n  PACKET_HEADER_SEQUENCE_MAX: 255, // 8 bit\n\n  // HSBK value calculation\n  HSBK_MINIMUM_KELVIN: 2500,\n  HSBK_DEFAULT_KELVIN: 3500,\n  HSBK_MAXIMUM_KELVIN: 9000,\n  HSBK_MINIMUM_BRIGHTNESS: 0,\n  HSBK_MAXIMUM_BRIGHTNESS: 100,\n  HSBK_MINIMUM_SATURATION: 0,\n  HSBK_MAXIMUM_SATURATION: 100,\n  HSBK_MINIMUM_HUE: 0,\n  HSBK_MAXIMUM_HUE: 360,\n\n  // RGB value\n  RGB_MAXIMUM_VALUE: 255,\n  RGB_MINIMUM_VALUE: 0,\n\n  // Infrared values\n  IR_MINIMUM_BRIGHTNESS: 0,\n  IR_MAXIMUM_BRIGHTNESS: 100,\n\n  // Waveform values, order is important here\n  LIGHT_WAVEFORMS: [\n    'SAW',\n    'SINE',\n    'HALF_SINE',\n    'TRIANGLE',\n    'PULSE'\n  ],\n\n  // Packet types used by internal sending process\n  PACKET_TRANSACTION_TYPES: {\n    ONE_WAY: 0,\n    REQUEST_RESPONSE: 1\n  },\n\n  // Maps color names to hue and saturation mapping\n  // Kelvin and brightness are kept the same\n  COLOR_NAME_HS_VALUES: {\n    white: {hue: 0, saturation: 0},\n    red: {hue: 0, saturation: 100},\n    orange: {hue: 35, saturation: 100},\n    yellow: {hue: 59, saturation: 100},\n    cyan: {hue: 179, saturation: 100},\n    green: {hue: 120, saturation: 100},\n    blue: {hue: 249, saturation: 100},\n    purple: {hue: 279, saturation: 100},\n    pink: {hue: 324, saturation: 100}\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/utils.js":"'use strict';\n\nvar os = require('os');\nvar constants = require('../lifx').constants;\nvar productDetailList = require('./products.json');\nvar utils = exports;\n\n/**\n * Return all ip addresses of the machine\n * @return {Array} list containing ip address info\n */\nutils.getHostIPs = function() {\n  var ips = [];\n  var ifaces = os.networkInterfaces();\n  Object.keys(ifaces).forEach(function(ifname) {\n    ifaces[ifname].forEach(function(iface) {\n      ips.push(iface.address);\n    });\n  });\n  return ips;\n};\n\n/**\n * Generates a random hex string of the given length\n * @example\n * // returns something like 8AF1\n * utils.getRandomHexString(4)\n * @example\n * // returns something like 0D41C8AF\n * utils.getRandomHexString()\n * @param  {Number} [length=8] string length to generate\n * @return {String}            random hex string\n */\nutils.getRandomHexString = function(length) {\n  var string = '';\n  var chars = '0123456789ABCDEF';\n\n  if (!length) {\n    length = 8;\n  }\n\n  for (var i = 0; i < length; i++) {\n    var randomNumber = Math.floor(Math.random() * chars.length);\n    string += chars.substring(randomNumber, randomNumber + 1);\n  }\n\n  return string;\n};\n\n/**\n * Reads a little-endian unsigned 64-bit value and returns it as buffer\n * This function exists for easy replacing if a native method will be provided\n * by node.js and does not make sense like is\n * @param  {Buffer} buffer buffer to read from\n * @param  {Number} offset offset to begin reading from\n * @return {Buffer}        resulting 64-bit buffer\n */\nutils.readUInt64LE = function(buffer, offset) {\n  return buffer.slice(offset, offset + 8);\n};\n\n/**\n * Writes a 64-bit value provided as buffer and returns the result\n * This function exists for easy replacing if a native method will be provided\n * by node.js and does not make sense like is\n * @param  {Buffer} buffer buffer to write from\n * @param  {Number} offset offset to begin reading from\n * @param  {Buffer} input  the buffer to write\n * @return {Buffer}        resulting 64-bit buffer\n */\nutils.writeUInt64LE = function(buffer, offset, input) {\n  return input.copy(buffer, offset, 0, 8);\n};\n\n/**\n * Validates a given ip address is IPv4 format\n * @param  {String} ip IP address to validate\n * @return {Boolean}   is IPv4 format?\n */\nutils.isIpv4Format = function(ip) {\n  var ipv4Regex = /^(\\d{1,3}\\.){3}\\d{1,3}$/;\n  return ipv4Regex.test(ip);\n};\n\n/**\n * Converts an RGB Hex string to an object with decimal representations\n * @example rgbHexStringToObject('#FF00FF')\n * @param {String} rgbHexString hex value to parse, with leading #\n * @return {Object}             object with decimal values for r, g, b\n */\nutils.rgbHexStringToObject = function(rgbHexString) {\n  if (typeof rgbHexString !== 'string') {\n    throw new TypeError('LIFX util rgbHexStringToObject expects first parameter to be a string');\n  }\n  var hashChar = rgbHexString.substr(0, 1);\n  if (hashChar !== '#') {\n    throw new RangeError('LIFX util rgbHexStringToObject expects hex parameter with leading \\'#\\' sign');\n  }\n  var pureHex = rgbHexString.substr(1);\n  if (pureHex.length !== 6 && pureHex.length !== 3) {\n    throw new RangeError('LIFX util rgbHexStringToObject expects hex value parameter to be 3 or 6 chars long');\n  }\n\n  var r;\n  var g;\n  var b;\n\n  if (pureHex.length === 6) {\n    r = pureHex.substring(0, 2);\n    g = pureHex.substring(2, 4);\n    b = pureHex.substring(4, 6);\n  } else if (pureHex.length === 3) {\n    r = pureHex.substring(0, 1);\n    r += r;\n    g = pureHex.substring(1, 2);\n    g += g;\n    b = pureHex.substring(2, 3);\n    b += b;\n  }\n\n  return {\n    r: parseInt(r, 16),\n    g: parseInt(g, 16),\n    b: parseInt(b, 16)\n  };\n};\n\nutils.minNumberInArray = function(array) {\n  var sortedCopy = array.slice();\n  sortedCopy.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedCopy[0];\n};\n\nutils.maxNumberInArray = function(array) {\n  var sortedCopy = array.slice();\n  sortedCopy.sort(function(a, b) {\n    return a - b;\n  });\n  return sortedCopy[sortedCopy.length - 1];\n};\n\n/**\n * Converts an object with r,g,b integer values to an\n * hsb integer object\n * @param {Object} rgbObj object with r,g,b keys and values\n * @return {Object} hsbObj object with h,s,b keys and converted values\n */\nutils.rgbToHsb = function(rgbObj) {\n  var red = rgbObj.r / constants.RGB_MAXIMUM_VALUE;\n  var green = rgbObj.g / constants.RGB_MAXIMUM_VALUE;\n  var blue = rgbObj.b / constants.RGB_MAXIMUM_VALUE;\n  var rgb = [red, green, blue];\n  var hsb = {};\n\n  var max = utils.maxNumberInArray(rgb);\n  var min = utils.minNumberInArray(rgb);\n  var c = max - min;\n\n  // https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\n  var hue;\n  if (c === 0) {\n    hue = 0;\n  } else if (max === red) {\n    hue = ((green - blue) / c);\n    if (hue < 0) {\n      hue += 6;\n    }\n  } else if (max === green) {\n    hue = 2 + ((blue - red) / c);\n  } else { // max === blue\n    hue = 4 + ((red - green) / c);\n  }\n  hsb.h = Math.round(60 * hue);\n\n  // https://en.wikipedia.org/wiki/HSL_and_HSV#Lightness\n  var lightness = max;\n  hsb.b = Math.round(lightness * 100);\n\n  // https://en.wikipedia.org/wiki/HSL_and_HSV#Saturation\n  var saturation;\n  if (c === 0) {\n    saturation = 0;\n  } else {\n    saturation = (c / lightness);\n  }\n  hsb.s = Math.round(saturation * 100);\n\n  return hsb;\n};\n\n/**\n * Get's product and vendor details for the given id's\n * hsb integer object\n * @param {Number} vendorId id of the vendor\n * @param {Number} productId id of the product\n * @return {Object|Boolean} product and details vendor details or false if not found\n */\nutils.getHardwareDetails = function(vendorId, productId) {\n  for (var i = 0; i < productDetailList.length; i += 1) {\n    if (productDetailList[i].vid === vendorId) {\n      for (var j = 0; j < productDetailList[i].products.length; j += 1) {\n        if (productDetailList[i].products[j].pid === productId) {\n          return {\n            vendorName: productDetailList[i].name,\n            productName: productDetailList[i].products[j].name,\n            productFeatures: productDetailList[i].products[j].features\n          };\n        }\n      }\n    }\n  }\n\n  return false;\n};\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packet.js":"'use strict';\n\nvar constants = require('../lifx').constants;\nvar packets = require('./packets');\nvar utils = require('../lifx').utils;\nvar _ = require('lodash');\n\n/*\n  Package headers 36 bit in total consisting of\n  size - 2 bit\n  frameDescription - 2 bit\n\n  source - 4 bit\n  target - 6 bit\n  00 00 -\n  site - 6 bit\n\n  frameAddressDescription - 1 bit\n  sequence - 1 bit\n  time - 8 bit\n  type - 2 bit\n  00 00\n */\nvar Packet = {};\n\n/**\n * Mapping for types\n * @type {Array}\n */\nPacket.typeList = [\n  {id: 2, name: 'getService'},\n  {id: 3, name: 'stateService'},\n  {id: 12, name: 'getHostInfo'},\n  {id: 13, name: 'stateHostInfo'},\n  {id: 14, name: 'getHostFirmware'},\n  {id: 15, name: 'stateHostFirmware'},\n  {id: 16, name: 'getWifiInfo'},\n  {id: 17, name: 'stateWifiInfo'},\n  {id: 18, name: 'getWifiFirmware'},\n  {id: 19, name: 'stateWifiFirmware'},\n  // {id: 20, name: 'getPower'}, // These are for device level\n  // {id: 21, name: 'setPower'}, // and do not support duration value\n  // {id: 22, name: 'statePower'}, // since that we don't use them\n  {id: 23, name: 'getLabel'},\n  {id: 24, name: 'setLabel'},\n  {id: 25, name: 'stateLabel'},\n  {id: 32, name: 'getVersion'},\n  {id: 33, name: 'stateVersion'},\n  {id: 45, name: 'acknowledgement'},\n  {id: 48, name: 'getLocation'},\n  {id: 50, name: 'stateLocation'},\n  {id: 51, name: 'getGroup'},\n  {id: 53, name: 'stateGroup'},\n  {id: 54, name: 'getOwner'},\n  {id: 56, name: 'stateOwner'},\n  {id: 58, name: 'echoRequest'},\n  {id: 59, name: 'echoResponse'},\n  {id: 69, name: 'getTemperature'},\n  {id: 70, name: 'stateTemperature'},\n  {id: 101, name: 'getLight'},\n  {id: 102, name: 'setColor'},\n  {id: 103, name: 'setWaveform'},\n  {id: 107, name: 'stateLight'},\n  {id: 111, name: 'stateTemperature'},\n  // {id: 113, name: 'setSimpleEvent'},\n  // {id: 114, name: 'getSimpleEvent'},\n  // {id: 115, name: 'stateSimpleEvent'},\n  {id: 116, name: 'getPower'},\n  {id: 117, name: 'setPower'},\n  {id: 118, name: 'statePower'},\n  // {id: 119, name: 'setWaveformOptional'},\n  {id: 120, name: 'getInfrared'},\n  {id: 121, name: 'stateInfrared'},\n  {id: 122, name: 'setInfrared'},\n  {id: 401, name: 'getAmbientLight'},\n  {id: 402, name: 'stateAmbientLight'}\n  // {id: 403, name: 'getDimmerVoltage'},\n  // {id: 404, name: 'stateDimmerVoltage'}\n];\n\n/**\n * Parses a lifx packet header\n * @param {Buffer} buf Buffer containg lifx packet including header\n * @return {Object} parsed packet header\n */\nPacket.headerToObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Frame\n  obj.size = buf.readUInt16LE(offset);\n  offset += 2;\n\n  var frameDescription = buf.readUInt16LE(offset);\n  obj.addressable = (frameDescription & constants.ADDRESSABLE_BIT) !== 0;\n  obj.tagged = (frameDescription & constants.TAGGED_BIT) !== 0;\n  obj.origin = ((frameDescription & constants.ORIGIN_BITS) >> 14) !== 0;\n  obj.protocolVersion = (frameDescription & constants.PROTOCOL_VERSION_BITS);\n  offset += 2;\n\n  obj.source = buf.toString('hex', offset, offset + 4);\n  offset += 4;\n\n  // Frame address\n  obj.target = buf.toString('hex', offset, offset + 6);\n  offset += 6;\n\n  obj.reserved1 = buf.slice(offset, offset + 2);\n  offset += 2;\n\n  obj.site = buf.toString('utf8', offset, offset + 6);\n  obj.site = obj.site.replace(/\\0/g, '');\n  offset += 6;\n\n  var frameAddressDescription = buf.readUInt8(offset);\n  obj.ackRequired = (frameAddressDescription & constants.ACK_REQUIRED_BIT) !== 0;\n  obj.resRequired = (frameAddressDescription & constants.RESPONSE_REQUIRED_BIT) !== 0;\n  offset += 1;\n\n  obj.sequence = buf.readUInt8(offset);\n  offset += 1;\n\n  // Protocol header\n  obj.time = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  obj.type = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.reserved2 = buf.slice(offset, offset + 2);\n  offset += 2;\n\n  return obj;\n};\n\n/**\n * Parses a lifx packet\n * @param {Buffer} buf Buffer with lifx packet\n * @return {Object} parsed packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n\n  // Try to read header of packet\n  try {\n    obj = this.headerToObject(buf);\n  } catch (err) {\n    // If this fails return with error\n    return err;\n  }\n\n  if (obj.type !== undefined) {\n    var typeName = _.result(_.find(this.typeList, {id: obj.type}), 'name');\n    if (packets[typeName] !== undefined) {\n      if (typeof packets[typeName].toObject === 'function') {\n        var specificObj = packets[typeName].toObject(buf.slice(constants.PACKET_HEADER_SIZE));\n        obj = _.extend(obj, specificObj);\n      }\n    }\n  }\n\n  return obj;\n};\n\n/**\n * Creates a lifx packet header from a given object\n * @param {Object} obj Object containg header configuration for packet\n * @return {Buffer} packet header buffer\n */\nPacket.headerToBuffer = function(obj) {\n  var buf = new Buffer(36);\n  buf.fill(0);\n  var offset = 0;\n\n  // Frame\n  buf.writeUInt16LE(obj.size, offset);\n  offset += 2;\n\n  if (obj.protocolVersion === undefined) {\n    obj.protocolVersion = constants.PROTOCOL_VERSION_CURRENT;\n  }\n  var frameDescription = obj.protocolVersion;\n\n  if (obj.addressable !== undefined && obj.addressable === true) {\n    frameDescription |= constants.ADDRESSABLE_BIT;\n  } else if (obj.source !== undefined && obj.source.length > 0 && obj.source !== '00000000') {\n    frameDescription |= constants.ADDRESSABLE_BIT;\n  }\n\n  if (obj.tagged !== undefined && obj.tagged === true) {\n    frameDescription |= constants.TAGGED_BIT;\n  }\n\n  if (obj.origin !== undefined && obj.origin === true) {\n    // 0 or 1 to the 14 bit\n    frameDescription |= (1 << 14);\n  }\n\n  buf.writeUInt16LE(frameDescription, offset);\n  offset += 2;\n\n  if (obj.source !== undefined && obj.source.length > 0) {\n    if (obj.source.length === 8) {\n      buf.write(obj.source, offset, 4, 'hex');\n    } else {\n      throw new RangeError('LIFX source must be given in 8 characters');\n    }\n  }\n  offset += 4;\n\n  // Frame address\n  if (obj.target !== undefined && obj.target !== null) {\n    buf.write(obj.target, offset, 6, 'hex');\n  }\n  offset += 6;\n\n  // reserved1\n  offset += 2;\n\n  if (obj.site !== undefined && obj.site !== null) {\n    buf.write(obj.site, offset, 6, 'utf8');\n  }\n  offset += 6;\n\n  var frameAddressDescription = 0;\n  if (obj.ackRequired !== undefined && obj.ackRequired === true) {\n    frameAddressDescription |= constants.ACK_REQUIRED_BIT;\n  }\n\n  if (obj.resRequired !== undefined && obj.resRequired === true) {\n    frameAddressDescription |= constants.RESPONSE_REQUIRED_BIT;\n  }\n  buf.writeUInt8(frameAddressDescription, offset);\n  offset += 1;\n\n  if (typeof obj.sequence === 'number') {\n    buf.writeUInt8(obj.sequence, offset);\n  }\n  offset += 1;\n\n  // Protocol header\n  if (obj.time !== undefined) {\n    utils.writeUInt64LE(buf, offset, obj.time);\n  }\n  offset += 8;\n\n  if (typeof obj.type === 'number') {\n    obj.type = _.result(_.find(this.typeList, {id: obj.type}), 'id');\n  } else if (typeof obj.type === 'string' || obj.type instanceof String) {\n    obj.type = _.result(_.find(this.typeList, {name: obj.type}), 'id');\n  }\n  if (obj.type === undefined) {\n    throw new Error('Unknown lifx packet of type: ' + obj.type);\n  }\n  buf.writeUInt16LE(obj.type, offset);\n  offset += 2;\n\n  // reserved2\n  offset += 2;\n\n  return buf;\n};\n\n/**\n * Creates a packet from a configuration object\n * @param {Object} obj Object with configuration for packet\n * @return {Buffer|Boolean} the packet or false in case of error\n */\nPacket.toBuffer = function(obj) {\n  if (obj.type !== undefined) {\n    // Map id to string if needed\n    if (typeof obj.type === 'number') {\n      obj.type = _.result(_.find(this.typeList, {id: obj.type}), 'name');\n    } else if (typeof obj.type === 'string' || obj.type instanceof String) {\n      obj.type = _.result(_.find(this.typeList, {name: obj.type}), 'name');\n    }\n\n    if (obj.type !== undefined) {\n      if (typeof packets[obj.type].toBuffer === 'function') {\n        var packetTypeData = packets[obj.type].toBuffer(obj);\n        return Buffer.concat([\n          this.headerToBuffer(obj),\n          packetTypeData\n        ]);\n      }\n      return this.headerToBuffer(obj);\n    }\n  }\n\n  return false;\n};\n\n/**\n * Creates a new packet by the given type\n * Note: This does not validate the given params\n * @param  {String|Number} type the type of packet to create as number or string\n * @param  {Object} params further settings to pass\n * @param  {String} [source] the source of the packet, length 8\n * @param  {String} [target] the target of the packet, length 12\n * @return {Object} The prepared packet object including header\n */\nPacket.create = function(type, params, source, target) {\n  var obj = {};\n  if (type !== undefined) {\n    // Check if type is valid\n    if (typeof type === 'string' || type instanceof String) {\n      obj.type = _.result(_.find(this.typeList, {name: type}), 'id');\n    } else if (typeof type === 'number') {\n      var typeMatch = _.find(this.typeList, {id: type});\n      obj.type = _.result(typeMatch, 'id');\n      type = _.result(typeMatch, 'name');\n    }\n    if (obj.type === undefined) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n  obj.size = constants.PACKET_HEADER_SIZE + packets[type].size;\n\n  if (source !== undefined) {\n    obj.source = source;\n  }\n  if (target !== undefined) {\n    obj.target = target;\n  }\n  if (packets[type].tagged !== undefined) {\n    obj.tagged = packets[type].tagged;\n  }\n\n  return _.assign(obj, params);\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/index.js":"var packets = exports;\n\n/*\n * Device related packages\n */\npackets.getService = require('./getService');\npackets.stateService = require('./stateService');\n\npackets.getHostInfo = require('./getHostInfo');\npackets.stateHostInfo = require('./stateHostInfo');\n\npackets.getHostFirmware = require('./getHostFirmware');\npackets.stateHostFirmware = require('./stateHostFirmware');\n\npackets.getWifiInfo = require('./getWifiInfo');\npackets.stateWifiInfo = require('./stateWifiInfo');\n\npackets.getWifiFirmware = require('./getWifiFirmware');\npackets.stateWifiFirmware = require('./stateWifiFirmware');\n\npackets.getLabel = require('./getLabel');\npackets.setLabel = require('./setLabel');\npackets.stateLabel = require('./stateLabel');\n\npackets.getPower = require('./getPower');\npackets.setPower = require('./setPower');\npackets.statePower = require('./statePower');\n\npackets.getVersion = require('./getVersion');\npackets.stateVersion = require('./stateVersion');\n\npackets.acknowledgement = require('./acknowledgement');\n\npackets.echoRequest = require('./echoRequest');\npackets.echoResponse = require('./echoResponse');\n\npackets.getLocation = require('./getLocation');\npackets.stateLocation = require('./stateLocation');\n\npackets.getOwner = require('./getOwner');\npackets.stateOwner = require('./stateOwner');\n\npackets.getGroup = require('./getGroup');\npackets.stateGroup = require('./stateGroup');\n\n/*\n * Light device related packages\n */\npackets.getLight = require('./getLight');\npackets.stateLight = require('./stateLight');\n\npackets.setColor = require('./setColor');\npackets.setWaveform = require('./setWaveform');\n\npackets.getTemperature = require('./getTemperature');\npackets.stateTemperature = require('./stateTemperature');\n\npackets.getInfrared = require('./getInfrared');\npackets.setInfrared = require('./setInfrared');\npackets.stateInfrared = require('./stateInfrared');\n\n/*\n * Sensor related packages\n */\npackets.getAmbientLight = require('./getAmbientLight');\npackets.stateAmbientLight = require('./stateAmbientLight');\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getService.js":"'use strict';\n\nvar Packet = {\n  size: 0,\n  tagged: true\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateService.js":"'use strict';\n\nvar Packet = {\n  size: 5\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateService LIFX packet');\n  }\n\n  obj.service = buf.readUInt8(offset);\n  offset += 1;\n\n  /*\n    Map service to a value\n    -------------\n    UDP -> 1\n    reserved -> 2\n    reserved -> 3\n    reserved -> 4\n  */\n  if (obj.service === 1) {\n    obj.service = 'udp';\n  } else if (obj.service >= 2 && obj.service <= 4) {\n    obj.serice = 'reserved';\n  } else {\n    obj.serice = 'unknown';\n  }\n\n  obj.port = buf.readUInt32LE(offset);\n  offset += 4;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeUInt8(obj.service, offset);\n  offset += 1;\n\n  buf.writeUInt32LE(obj.port, offset);\n  offset += 4;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getHostInfo.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateHostInfo.js":"'use strict';\n\nvar Packet = {\n  size: 14\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Check length\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateHostInfo LIFX packet');\n  }\n\n  obj.signal = buf.readFloatLE(offset);\n  offset += 4;\n\n  obj.tx = buf.readUInt32LE(offset);\n  offset += 4;\n\n  obj.rx = buf.readUInt32LE(offset);\n  offset += 4;\n\n  obj.mcuTemperature = buf.readUInt16LE(offset);\n  offset += 2;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeFloatLE(obj.signal, offset);\n  offset += 4;\n\n  buf.writeUInt32LE(obj.tx, offset);\n  offset += 4;\n\n  buf.writeUInt32LE(obj.rx, offset);\n  offset += 4;\n\n  buf.writeUInt16LE(obj.mcuTemperature, offset);\n  offset += 2;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getHostFirmware.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateHostFirmware.js":"'use strict';\n\nvar utils = require('../../lifx').utils;\n\nvar Packet = {\n  size: 20\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Check length\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateHostFirmware LIFX packet');\n  }\n\n  obj.build = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  obj.install = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  var version = buf.readUInt32LE(offset);\n  obj.majorVersion = (version >> 16) & 0xFF;\n  obj.minorVersion = version & 0xFF;\n  offset += 4;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  utils.writeUInt64LE(buf, offset, obj.build);\n  offset += 8;\n\n  utils.writeUInt64LE(buf, offset, obj.install);\n  offset += 8;\n\n  buf.writeUInt32LE(obj.version, offset);\n  offset += 4;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getWifiInfo.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateWifiInfo.js":"'use strict';\n\nvar Packet = {\n  size: 14\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Check length\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateWifiInfo LIFX packet');\n  }\n\n  obj.signal = buf.readFloatLE(offset);\n  offset += 4;\n\n  obj.tx = buf.readUInt32LE(offset);\n  offset += 4;\n\n  obj.rx = buf.readUInt32LE(offset);\n  offset += 4;\n\n  obj.mcuTemperature = buf.readUInt16LE(offset);\n  offset += 2;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeFloatLE(obj.signal, offset);\n  offset += 4;\n\n  buf.writeUInt32LE(obj.tx, offset);\n  offset += 4;\n\n  buf.writeUInt32LE(obj.rx, offset);\n  offset += 4;\n\n  buf.writeUInt16LE(obj.mcuTemperature, offset);\n  offset += 2;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getWifiFirmware.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateWifiFirmware.js":"'use strict';\n\nvar utils = require('../../lifx').utils;\n\nvar Packet = {\n  size: 20\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Check length\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateWifiFirmware LIFX packet');\n  }\n\n  obj.build = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  obj.install = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  var version = buf.readUInt32LE(offset);\n  obj.majorVersion = (version >> 16) & 0xFF;\n  obj.minorVersion = version & 0xFF;\n  offset += 4;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  utils.writeUInt64LE(buf, offset, obj.build);\n  offset += 8;\n\n  utils.writeUInt64LE(buf, offset, obj.install);\n  offset += 8;\n\n  buf.writeUInt32LE(obj.version, offset);\n  offset += 4;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getLabel.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/setLabel.js":"'use strict';\n\nvar Packet = {\n  size: 32\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for setLabel LIFX packet');\n  }\n\n  obj.label = buf.toString('utf8', offset, offset + 32);\n  obj.label = obj.label.replace(/\\0/g, '');\n  offset += 32;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @param  {string} obj.label label to set, maximum 32 bytes\n * @return {Buffer} packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.write(obj.label, offset, 32, 'utf8');\n  offset += 32;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateLabel.js":"'use strict';\n\nvar Packet = {\n  size: 32\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateLabel LIFX packet');\n  }\n\n  obj.label = buf.toString('utf8', offset, offset + 32);\n  obj.label = obj.label.replace(/\\0/g, '');\n  offset += 32;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @param  {string} obj.label label to set, maximum 32 bytes\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.write(obj.label, offset, 32, 'utf8');\n  offset += 32;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getPower.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/setPower.js":"'use strict';\n\nvar Packet = {\n  size: 6\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for setPower LIFX packet');\n  }\n\n  obj.level = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.duration = buf.readUInt32LE(offset);\n  offset += 4;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @param  {Number} obj.level 0 for off, 65535 for on\n * @param  {Number} [obj.duration] transition time in milliseconds\n * @return {Buffer} packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  if (obj.level !== 0 && obj.level !== 65535) {\n    throw new RangeError('Invalid level given for setPower LIFX packet, only 0 and 65535 are supported');\n  }\n  buf.writeUInt16LE(obj.level, offset);\n  offset += 2;\n\n  // Duration is 0 by default\n  if (obj.duration !== undefined) {\n    buf.writeUInt32LE(obj.duration, offset);\n  }\n  offset += 4;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/statePower.js":"'use strict';\n\nvar Packet = {\n  size: 2\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for statePower LIFX packet');\n  }\n\n  obj.level = buf.readUInt16LE(offset);\n  offset += 2;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeUInt16LE(obj.level, offset);\n  offset += 2;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getVersion.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateVersion.js":"'use strict';\n\nvar _ = require('lodash');\nvar constants = require('../../lifx').constants;\n\nvar Packet = {\n  size: 12\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Check length\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateHostFirmware LIFX packet');\n  }\n\n  obj.vendorId = buf.readUInt32LE(offset);\n  var vendor = _.find(constants.LIFX_VENDOR_IDS, {id: obj.vendorId});\n  if (vendor !== undefined) {\n    obj.vendorName = vendor.name;\n  }\n  offset += 4;\n\n  obj.productId = buf.readUInt32LE(offset);\n  offset += 4;\n\n  obj.version = buf.readUInt32LE(offset);\n  offset += 4;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeUInt32LE(obj.vendor, offset);\n  offset += 4;\n\n  buf.writeUInt32LE(obj.product, offset);\n  offset += 4;\n\n  buf.writeUInt32LE(obj.version, offset);\n  offset += 4;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/acknowledgement.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/echoRequest.js":"'use strict';\n\nvar Packet = {\n  size: 64\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Check length\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for echoRequest LIFX packet');\n  }\n\n  obj.payload = buf.toString('utf8', offset, offset + 64);\n  offset += 64;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * This packet expects payload field of max. length 64 utf8\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.write(obj.payload, offset, 64);\n  offset += 64;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/echoResponse.js":"'use strict';\n\nvar Packet = {\n  size: 64\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  // Check length\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for echoResponse LIFX packet');\n  }\n\n  obj.payload = buf.toString('utf8', offset, offset + 64);\n  obj.payload = obj.payload.replace(/\\0/g, '');\n  offset += 64;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * This packet expects payload field of max. length 64 utf8\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.write(obj.payload, offset, 64);\n  offset += 64;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getLocation.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateLocation.js":"'use strict';\n\nvar utils = require('../../lifx').utils;\n\nvar Packet = {\n  size: 56\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateLocation LIFX packet');\n  }\n\n  obj.location = buf.toString('hex', offset, offset + 16);\n  offset += 16;\n\n  obj.label = buf.toString('utf8', offset, offset + 32);\n  obj.label = obj.label.replace(/\\0/g, '');\n  offset += 32;\n\n  obj.updatedAt = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.write(obj.location, offset, 16, 'hex');\n  offset += 16;\n\n  buf.write(obj.label, offset, 32, 'utf8');\n  offset += 32;\n\n  utils.writeUInt64LE(buf, offset, obj.updatedAt);\n  offset += 8;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getOwner.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateOwner.js":"'use strict';\n\nvar utils = require('../../lifx').utils;\n\nvar Packet = {\n  size: 56\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateOwner LIFX packet');\n  }\n\n  obj.owner = buf.toString('hex', offset, offset + 16);\n  offset += 16;\n\n  obj.label = buf.toString('utf8', offset, offset + 32);\n  obj.label = obj.label.replace(/\\0/g, '');\n  offset += 32;\n\n  obj.updatedAt = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  if (obj.owner !== undefined) {\n    buf.write(obj.owner, offset, 16, 'hex');\n    offset += 16;\n  }\n\n  if (obj.label !== undefined) {\n    buf.write(obj.label, offset, 32, 'utf8');\n    offset += 32;\n  }\n\n  if (obj.updatedAt !== undefined) {\n    utils.writeUInt64LE(buf, offset, obj.updatedAt);\n    offset += 8;\n  }\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getGroup.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateGroup.js":"'use strict';\n\nvar utils = require('../../lifx').utils;\n\nvar Packet = {\n  size: 56\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateGroup LIFX packet');\n  }\n\n  obj.group = buf.toString('hex', offset, offset + 16);\n  offset += 16;\n\n  obj.label = buf.toString('utf8', offset, offset + 32);\n  obj.label = obj.label.replace(/\\0/g, '');\n  offset += 32;\n\n  obj.updatedAt = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.write(obj.group, offset, 16, 'hex');\n  offset += 16;\n\n  buf.write(obj.label, offset, 32, 'utf8');\n  offset += 32;\n\n  utils.writeUInt64LE(buf, offset, obj.updatedAt);\n  offset += 8;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getLight.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateLight.js":"'use strict';\n\nvar utils = require('../../lifx').utils;\n\nvar Packet = {\n  size: 52\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateLight LIFX packet');\n  }\n\n  obj.color = {};\n  obj.color.hue = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.saturation = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.brightness = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.kelvin = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.dim = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.power = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.label = buf.toString('utf8', offset, offset + 32);\n  obj.label = obj.label.replace(/\\0/g, '');\n  offset += 32;\n\n  obj.tags = utils.readUInt64LE(buf, offset);\n  offset += 8;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeUInt16LE(obj.color.hue, offset);\n  offset += 2;\n  buf.writeUInt16LE(obj.color.saturation, offset);\n  offset += 2;\n  buf.writeUInt16LE(obj.color.brightness, offset);\n  offset += 2;\n  buf.writeUInt16LE(obj.color.kelvin, offset);\n  offset += 2;\n\n  buf.writeUInt16LE(obj.dim, offset);\n  offset += 2;\n\n  buf.writeUInt16LE(obj.power, offset);\n  offset += 2;\n\n  buf.write(obj.label, offset, 32, 'utf8');\n  offset += 32;\n\n  utils.writeUInt64LE(buf, offset, obj.tags);\n  offset += 8;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/setColor.js":"'use strict';\n\nvar constants = require('../../lifx').constants;\n\nvar Packet = {\n  size: 13\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for setColor LIFX packet');\n  }\n\n  obj.stream = buf.readUInt8(offset);\n  offset += 1;\n\n  obj.color = {};\n  obj.color.hue = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.saturation = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.brightness = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.kelvin = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.duration = buf.readUInt32LE(offset);\n  offset += 4;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @param  {Object} obj.color an objects with colors to set\n * @param  {Number} obj.color.hue between 0 and 65535\n * @param  {Number} obj.color.saturation between 0 and 65535\n * @param  {Number} obj.color.brightness between 0 and 65535\n * @param  {Number} obj.color.kelvin between 2500 and 9000\n * @param  {Number} [obj.duration] transition time in milliseconds\n * @return {Buffer} packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  // obj.stream field has unknown function so leave it as 0\n  offset += 1;\n\n  if (typeof obj.hue !== 'number' && obj.hue < 0 || obj.hue > 65535) {\n    throw new RangeError('Invalid color hue given for setColor LIFX packet, must be a number between 0 and 65535');\n  }\n  buf.writeUInt16LE(obj.hue, offset);\n  offset += 2;\n\n  if (typeof obj.saturation !== 'number' && obj.saturation < 0 || obj.saturation > 65535) {\n    throw new RangeError('Invalid color saturation given for setColor LIFX packet, must be a number between 0 and 65535');\n  }\n  buf.writeUInt16LE(obj.saturation, offset);\n  offset += 2;\n\n  if (typeof obj.brightness !== 'number' && obj.brightness < 0 || obj.brightness > 65535) {\n    throw new RangeError('Invalid color brightness given for setColor LIFX packet, must be a number between 0 and 65535');\n  }\n  buf.writeUInt16LE(obj.brightness, offset);\n  offset += 2;\n\n  if (obj.kelvin === undefined) {\n    obj.kelvin = constants.HSBK_DEFAULT_KELVIN;\n  }\n  if (typeof obj.kelvin !== 'number' && obj.kelvin < 2500 || obj.kelvin > 9000) {\n    throw new RangeError('Invalid color kelvin given for setColor LIFX packet, must be a number between 2500 and 9000');\n  }\n  buf.writeUInt16LE(obj.kelvin, offset);\n  offset += 2;\n\n  // Duration is 0 by default\n  if (obj.duration !== undefined) {\n    buf.writeUInt32LE(obj.duration, offset);\n  }\n  offset += 4;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/setWaveform.js":"'use strict';\n\nvar constants = require('../../lifx').constants;\n\nvar Packet = {\n  size: 21\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for setWaveform LIFX packet');\n  }\n\n  obj.stream = buf.readUInt8(offset);\n  offset += 1;\n\n  obj.isTransient = buf.readUInt8(offset);\n  offset += 1;\n\n  obj.color = {};\n  obj.color.hue = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.saturation = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.brightness = buf.readUInt16LE(offset);\n  offset += 2;\n  obj.color.kelvin = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.period = buf.readUInt32LE(offset);\n  offset += 4;\n\n  obj.cycles = buf.readFloatLE(offset);\n  offset += 4;\n\n  obj.skewRatio = buf.readUInt16LE(offset);\n  offset += 2;\n\n  obj.waveform = buf.readUInt8(offset);\n  offset += 1;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object}  obj object with configuration data\n * @param  {Boolean} obj.isTransient restore color used before effect\n * @param  {Object}  obj.color an objects with colors to set\n * @param  {Number}  obj.color.hue between 0 and 65535\n * @param  {Number}  obj.color.saturation between 0 and 65535\n * @param  {Number}  obj.color.brightness between 0 and 65535\n * @param  {Number}  [obj.color.kelvin=3500] between 2500 and 9000\n * @param  {Number}  obj.period length of one cycle in milliseconds\n * @param  {Number}  obj.cycles how often to repeat through effect\n * @param  {Number}  obj.skewRatio distribution between time on original and new color , positive is for more new color, negative for original color\n * @param  {Number}  obj.waveform between 0 and 4 for form of effect\n * @return {Buffer}  packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  // obj.stream field has unknown function so leave it as 0\n  offset += 1;\n\n  if (obj.isTransient === undefined) {\n    throw new TypeError('obj.isTransient value must be given for setWaveform LIFX packet');\n  }\n  if (typeof obj.isTransient !== 'boolean') {\n    throw new TypeError('Invalid isTransient value given for setWaveform LIFX packet, must be boolean');\n  }\n  buf.writeUInt8(obj.isTransient, offset);\n  offset += 1;\n\n  if (typeof obj.color !== 'object') {\n    throw new TypeError('Invalid object for color given for setWaveform LIFX packet');\n  }\n\n  if (typeof obj.color.hue !== 'number' && obj.color.hue < 0 || obj.color.hue > 65535) {\n    throw new RangeError('Invalid color hue given for setWaveform LIFX packet, must be a number between 0 and 65535');\n  }\n  buf.writeUInt16LE(obj.color.hue, offset);\n  offset += 2;\n\n  if (typeof obj.color.saturation !== 'number' && obj.color.saturation < 0 || obj.color.saturation > 65535) {\n    throw new RangeError('Invalid color saturation given for setWaveform LIFX packet, must be a number between 0 and 65535');\n  }\n  buf.writeUInt16LE(obj.color.saturation, offset);\n  offset += 2;\n\n  if (typeof obj.color.brightness !== 'number' && obj.color.brightness < 0 || obj.color.brightness > 65535) {\n    throw new RangeError('Invalid color brightness given for setWaveform LIFX packet, must be a number between 0 and 65535');\n  }\n  buf.writeUInt16LE(obj.color.brightness, offset);\n  offset += 2;\n\n  if (obj.color.kelvin === undefined) {\n    obj.color.kelvin = constants.HSBK_DEFAULT_KELVIN;\n  }\n  if (typeof obj.color.kelvin !== 'number' && obj.color.kelvin < 2500 || obj.color.kelvin > 9000) {\n    throw new RangeError('Invalid color kelvin given for setWaveform LIFX packet, must be a number between 2500 and 9000');\n  }\n  buf.writeUInt16LE(obj.color.kelvin, offset);\n  offset += 2;\n\n  if (obj.period === undefined) {\n    throw new TypeError('obj.period value must be given for setWaveform LIFX packet');\n  }\n  if (typeof obj.period !== 'number') {\n    throw new TypeError('Invalid period type given for setWaveform LIFX packet, must be a number');\n  }\n  buf.writeUInt32LE(obj.period, offset);\n  offset += 4;\n\n  if (obj.cycles === undefined) {\n    throw new TypeError('obj.cycles value must be given for setWaveform LIFX packet');\n  }\n  if (typeof obj.cycles !== 'number') {\n    throw new TypeError('Invalid cycles type given for setWaveform LIFX packet, must be a number');\n  }\n  buf.writeFloatLE(obj.cycles, offset);\n  offset += 4;\n\n  if (obj.skewRatio === undefined) {\n    throw new TypeError('obj.skewRatio value must be given for setWaveform LIFX packet');\n  }\n  if (typeof obj.skewRatio !== 'number') {\n    throw new TypeError('Invalid skewRatio type given for setWaveform LIFX packet, must be a number');\n  }\n  buf.writeInt16LE(obj.skewRatio, offset);\n  offset += 2;\n\n  if (obj.waveform === undefined) {\n    throw new TypeError('obj.waveform value must be given for setWaveform LIFX packet');\n  }\n  if (typeof obj.waveform !== 'number' && obj.waveform < 0 || obj.waveform > (constants.LIGHT_WAVEFORMS.length - 1)) {\n    throw new RangeError('Invalid waveform value given for setWaveform LIFX packet, must be a number between 0 and ' + (constants.LIGHT_WAVEFORMS.length - 1));\n  }\n  buf.writeUInt8(obj.waveform, offset);\n  offset += 1;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getTemperature.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateTemperature.js":"'use strict';\n\nvar Packet = {\n  size: 2\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateTemperature LIFX packet');\n  }\n\n  obj.temperature = buf.readUInt16LE(offset);\n  offset += 2;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeUInt16LE(obj.temperature, offset);\n  offset += 2;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getInfrared.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/setInfrared.js":"'use strict';\n\nvar Packet = {\n  size: 2\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for setInfrared LIFX packet');\n  }\n\n  obj.brightness = buf.readUInt16LE(offset);\n  offset += 2;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @param  {Number} obj.brightness between 0 and 65535\n * @return {Buffer} packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  if (typeof obj.brightness !== 'number' && obj.brightness < 0 && obj.brightness > 65535) {\n    throw new RangeError('Invalid brightness given for setInfrared LIFX packet, must be a number between 0 and 65535');\n  }\n  buf.writeUInt16LE(obj.brightness, offset);\n  offset += 2;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateInfrared.js":"'use strict';\n\nvar Packet = {\n  size: 2\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateInfrared LIFX packet');\n  }\n\n  obj.brightness = buf.readUInt16LE(offset);\n  offset += 2;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeUInt16LE(obj.brightness, offset);\n  offset += 2;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/getAmbientLight.js":"'use strict';\n\nvar Packet = {\n  size: 0\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/packets/stateAmbientLight.js":"'use strict';\n\nvar Packet = {\n  size: 4\n};\n\n/**\n * Converts packet specific data from a buffer to an object\n * @param  {Buffer} buf Buffer containing only packet specific data no header\n * @return {Object}     Information contained in packet\n */\nPacket.toObject = function(buf) {\n  var obj = {};\n  var offset = 0;\n\n  if (buf.length !== this.size) {\n    throw new Error('Invalid length given for stateAmbientLight LIFX packet');\n  }\n\n  obj.flux = buf.readFloatLE(offset);\n  offset += 4;\n\n  return obj;\n};\n\n/**\n * Converts the given packet specific object into a packet\n * @param  {Object} obj object with configuration data\n * @param  {Number} obj.flux flux value to set\n * @return {Buffer}     packet\n */\nPacket.toBuffer = function(obj) {\n  var buf = new Buffer(this.size);\n  buf.fill(0);\n  var offset = 0;\n\n  buf.writeFloatLE(obj.flux, offset);\n  offset += 4;\n\n  return buf;\n};\n\nmodule.exports = Packet;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/light.js":"'use strict';\n\nvar packet = require('../lifx').packet;\nvar constants = require('../lifx').constants;\nvar utils = require('../lifx').utils;\nvar _ = require('lodash');\n\n/**\n * A representation of a light bulb\n * @class\n * @param {Obj} constr constructor object\n * @param {Lifx/Client} constr.client the client the light belongs to\n * @param {String} constr.id the id used to target the light\n * @param {String} constr.address ip address of the light\n * @param {Number} constr.port port of the light\n * @param {Number} constr.seenOnDiscovery on which discovery the light was last seen\n */\nfunction Light(constr) {\n  this.client = constr.client;\n  this.id = constr.id; // Used to target the light\n  this.address = constr.address;\n  this.port = constr.port;\n  this.label = null;\n  this.status = 'on';\n\n  this.seenOnDiscovery = constr.seenOnDiscovery;\n}\n\n/**\n * Turns the light off\n * @example light('192.168.2.130').off()\n * @param {Number} [duration] transition time in milliseconds\n * @param {Function} [callback] called when light did receive message\n */\nLight.prototype.off = function(duration, callback) {\n  if (duration !== undefined && typeof duration !== 'number') {\n    throw new RangeError('LIFX light off method expects duration to be a number');\n  }\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('LIFX light off method expects callback to be a function');\n  }\n  var packetObj = packet.create('setPower', {level: 0, duration: duration}, this.client.source);\n  packetObj.target = this.id;\n  this.client.send(packetObj, callback);\n};\n\n/**\n * Turns the light on\n * @example light('192.168.2.130').on()\n * @param {Number} [duration] transition time in milliseconds\n * @param {Function} [callback] called when light did receive message\n */\nLight.prototype.on = function(duration, callback) {\n  if (duration !== undefined && typeof duration !== 'number') {\n    throw new RangeError('LIFX light on method expects duration to be a number');\n  }\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('LIFX light on method expects callback to be a function');\n  }\n  var packetObj = packet.create('setPower', {level: 65535, duration: duration}, this.client.source);\n  packetObj.target = this.id;\n  this.client.send(packetObj, callback);\n};\n\n/**\n * Changes the color to the given HSBK value\n * @param {Number} hue        color hue from 0 - 360 (in °)\n * @param {Number} saturation color saturation from 0 - 100 (in %)\n * @param {Number} brightness color brightness from 0 - 100 (in %)\n * @param {Number} [kelvin=3500]   color kelvin between 2500 and 9000\n * @param {Number} [duration] transition time in milliseconds\n * @param {Function} [callback] called when light did receive message\n */\nLight.prototype.color = function(hue, saturation, brightness, kelvin, duration, callback) {\n  if (typeof hue !== 'number' || hue < constants.HSBK_MINIMUM_HUE || hue > constants.HSBK_MAXIMUM_HUE) {\n    throw new RangeError('LIFX light color method expects hue to be a number between ' +\n      constants.HSBK_MINIMUM_HUE + ' and ' + constants.HSBK_MAXIMUM_HUE\n    );\n  }\n  hue = Math.round(hue / constants.HSBK_MAXIMUM_HUE * 65535);\n\n  if (typeof saturation !== 'number' || saturation < constants.HSBK_MINIMUM_SATURATION || saturation > constants.HSBK_MAXIMUM_SATURATION) {\n    throw new RangeError('LIFX light color method expects saturation to be a number between ' +\n      constants.HSBK_MINIMUM_SATURATION + ' and ' + constants.HSBK_MAXIMUM_SATURATION\n    );\n  }\n  saturation = Math.round(saturation / constants.HSBK_MAXIMUM_SATURATION * 65535);\n\n  if (typeof brightness !== 'number' || brightness < constants.HSBK_MINIMUM_BRIGHTNESS || brightness > constants.HSBK_MAXIMUM_BRIGHTNESS) {\n    throw new RangeError('LIFX light color method expects brightness to be a number between ' +\n      constants.HSBK_MINIMUM_BRIGHTNESS + ' and ' + constants.HSBK_MAXIMUM_BRIGHTNESS\n    );\n  }\n  brightness = Math.round(brightness / constants.HSBK_MAXIMUM_BRIGHTNESS * 65535);\n\n  if (duration !== undefined && typeof duration !== 'number') {\n    throw new RangeError('LIFX light color method expects duration to be a number');\n  }\n\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('LIFX light color method expects callback to be a function');\n  }\n\n  var packetObj = packet.create('setColor', {\n    hue: hue,\n    saturation: saturation,\n    brightness: brightness,\n    kelvin: kelvin,\n    duration: duration\n  }, this.client.source);\n  packetObj.target = this.id;\n  this.client.send(packetObj, callback);\n};\n\n/**\n * Changes the color to the given rgb value\n * Note RGB poorly represents the color of light, prefer setting HSBK values with the color method\n * @example light.colorRgb(255, 0, 0)\n * @param {Integer} red value between 0 and 255 representing amount of red in color\n * @param {Integer} green value between 0 and 255 representing amount of green in color\n * @param {Integer} blue value between 0 and 255 representing amount of blue in color\n * @param {Number} [duration] transition time in milliseconds\n * @param {Function} [callback] called when light did receive message\n */\nLight.prototype.colorRgb = function(red, green, blue, duration, callback) {\n  if (typeof red !== 'number') {\n    throw new TypeError('LIFX light colorRgb method expects first parameter red to a number');\n  }\n  if (red < constants.RGB_MINIMUM_VALUE || red > constants.RGB_MAXIMUM_VALUE) {\n    throw new RangeError('LIFX light colorRgb method expects first parameter red to be between 0 and 255');\n  }\n  if (typeof green !== 'number') {\n    throw new TypeError('LIFX light colorRgb method expects second parameter green to a number');\n  }\n  if (green < constants.RGB_MINIMUM_VALUE || green > constants.RGB_MAXIMUM_VALUE) {\n    throw new RangeError('LIFX light colorRgb method expects second parameter green to be between 0 and 255');\n  }\n  if (typeof blue !== 'number') {\n    throw new TypeError('LIFX light colorRgb method expects third parameter blue to a number');\n  }\n  if (blue < constants.RGB_MINIMUM_VALUE || blue > constants.RGB_MAXIMUM_VALUE) {\n    throw new RangeError('LIFX light colorRgb method expects third parameter blue to be between 0 and 255');\n  }\n\n  if (duration !== undefined && typeof duration !== 'number') {\n    throw new RangeError('LIFX light colorRgb method expects duration to be a number');\n  }\n\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('LIFX light colorRgb method expects callback to be a function');\n  }\n\n  var hsbObj = utils.rgbToHsb({r: red, g: green, b: blue});\n  this.color(hsbObj.h, hsbObj.s, hsbObj.b, 3500, duration, callback);\n};\n\n/**\n * Changes the color to the given rgb value\n * Note RGB poorly represents the color of light, prefer setting HSBK values with the color method\n * @example light.colorRgb('#FF0000')\n * @param {String} hexString rgb hex string starting with # char\n * @param {Number} [duration] transition time in milliseconds\n * @param {Function} [callback] called when light did receive message\n */\nLight.prototype.colorRgbHex = function(hexString, duration, callback) {\n  if (typeof hexString !== 'string') {\n    throw new TypeError('LIFX light colorRgbHex method expects first parameter hexString to a string');\n  }\n\n  if (duration !== undefined && typeof duration !== 'number') {\n    throw new RangeError('LIFX light colorRgbHex method expects duration to be a number');\n  }\n\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('LIFX light colorRgbHex method expects callback to be a function');\n  }\n\n  var rgbObj = utils.rgbHexStringToObject(hexString);\n  var hsbObj = utils.rgbToHsb(rgbObj);\n  this.color(hsbObj.h, hsbObj.s, hsbObj.b, 3500, duration, callback);\n};\n\n/**\n * Sets the Maximum Infrared brightness\n * @param {Number} brightness infrared brightness from 0 - 100 (in %)\n * @param {Function} [callback] called when light did receive message\n */\nLight.prototype.maxIR = function(brightness, callback) {\n  if (typeof brightness !== 'number' || brightness < constants.IR_MINIMUM_BRIGHTNESS || brightness > constants.IR_MAXIMUM_BRIGHTNESS) {\n    throw new RangeError('LIFX light setMaxIR method expects brightness to be a number between ' +\n      constants.IR_MINIMUM_BRIGHTNESS + ' and ' + constants.IR_MAXIMUM_BRIGHTNESS\n    );\n  }\n  brightness = Math.round(brightness / constants.IR_MAXIMUM_BRIGHTNESS * 65535);\n\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('LIFX light setMaxIR method expects callback to be a function');\n  }\n\n  var packetObj = packet.create('setInfrared', {\n    brightness: brightness\n  }, this.client.source);\n  packetObj.target = this.id;\n  this.client.send(packetObj, callback);\n};\n\n/**\n * Requests the current state of the light\n * @param {Function} callback a function to accept the data\n */\nLight.prototype.getState = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getState method expects callback to be a function');\n  }\n  var packetObj = packet.create('getLight', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateLight', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    // Convert HSB to readable format\n    msg.color.hue = Math.round(msg.color.hue * (constants.HSBK_MAXIMUM_HUE / 65535));\n    msg.color.saturation = Math.round(msg.color.saturation * (constants.HSBK_MAXIMUM_SATURATION / 65535));\n    msg.color.brightness = Math.round(msg.color.brightness * (constants.HSBK_MAXIMUM_BRIGHTNESS / 65535));\n    // Convert power to readable format\n    if (msg.power === 65535) {\n      msg.power = 1;\n    }\n    callback(null, {\n      color: msg.color,\n      power: msg.power,\n      label: msg.label\n    });\n  }, sqnNumber);\n};\n\n/**\n * Requests the current maximum setting for the infrared channel\n * @param  {Function} callback a function to accept the data\n */\nLight.prototype.getMaxIR = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getMaxIR method expects callback to be a function');\n  }\n  var packetObj = packet.create('getInfrared', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateInfrared', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    msg.brightness = Math.round(msg.brightness * (constants.HSBK_MAXIMUM_BRIGHTNESS / 65535));\n\n    callback(null, msg.brightness);\n  }, sqnNumber);\n};\n\n/**\n * Requests hardware info from the light\n * @param {Function} callback a function to accept the data with error and\n *                   message as parameters\n */\nLight.prototype.getHardwareVersion = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getHardwareVersion method expects callback to be a function');\n  }\n  var packetObj = packet.create('getVersion', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateVersion', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    var versionInfo = _.pick(msg, [\n      'vendorId',\n      'productId',\n      'version'\n    ]);\n    callback(null, _.assign(\n      versionInfo,\n      utils.getHardwareDetails(versionInfo.vendorId, versionInfo.productId)\n    ));\n  }, sqnNumber);\n};\n\n/**\n * Requests used version from the microcontroller unit of the light\n * @param {Function} callback a function to accept the data\n */\nLight.prototype.getFirmwareVersion = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getFirmwareVersion method expects callback to be a function');\n  }\n  var packetObj = packet.create('getHostFirmware', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateHostFirmware', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    callback(null, _.pick(msg, [\n      'majorVersion',\n      'minorVersion'\n    ]));\n  }, sqnNumber);\n};\n\n/**\n * Requests infos from the microcontroller unit of the light\n * @param {Function} callback a function to accept the data\n */\nLight.prototype.getFirmwareInfo = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getFirmwareVersion method expects callback to be a function');\n  }\n  var packetObj = packet.create('getHostInfo', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateHostInfo', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    callback(null, _.pick(msg, [\n      'signal',\n      'tx',\n      'rx'\n    ]));\n  }, sqnNumber);\n};\n\n/**\n * Requests wifi infos from for the light\n * @param {Function} callback a function to accept the data\n */\nLight.prototype.getWifiInfo = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getFirmwareVersion method expects callback to be a function');\n  }\n  var packetObj = packet.create('getWifiInfo', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateWifiInfo', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    callback(null, _.pick(msg, [\n      'signal',\n      'tx',\n      'rx'\n    ]));\n  }, sqnNumber);\n};\n\n/**\n * Requests used version from the wifi controller unit of the light (wifi firmware version)\n * @param {Function} callback a function to accept the data\n */\nLight.prototype.getWifiVersion = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getFirmwareVersion method expects callback to be a function');\n  }\n  var packetObj = packet.create('getWifiFirmware', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateWifiFirmware', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    return callback(null, _.pick(msg, [\n      'majorVersion',\n      'minorVersion'\n    ]));\n  }, sqnNumber);\n};\n\n/**\n * Requests the label of the light\n * @param {Function} callback a function to accept the data\n * @param {Boolean} [cache=false] return cached result if existent\n * @return {Function} callback(err, label)\n */\nLight.prototype.getLabel = function(callback, cache) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getLabel method expects callback to be a function');\n  }\n  if (cache !== undefined && typeof cache !== 'boolean') {\n    throw new TypeError('LIFX light getLabel method expects cache to be a boolean');\n  }\n  if (cache === true) {\n    if (typeof this.label === 'string' && this.label.length > 0) {\n      return callback(null, this.label);\n    }\n  }\n  var packetObj = packet.create('getLabel', {\n    target: this.id\n  }, this.client.source);\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateLabel', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    return callback(null, msg.label);\n  }, sqnNumber);\n};\n\n/**\n * Sets the label of light\n * @example light.setLabel('Kitchen')\n * @param {String} label new label to be set, maximum 32 bytes\n * @param {Function} [callback] called when light did receive message\n */\nLight.prototype.setLabel = function(label, callback) {\n  if (label === undefined || typeof label !== 'string') {\n    throw new TypeError('LIFX light setLabel method expects label to be a string');\n  }\n  if (Buffer.byteLength(label, 'utf8') > 32) {\n    throw new RangeError('LIFX light setLabel method expects a maximum of 32 bytes as label');\n  }\n  if (label.length < 1) {\n    throw new RangeError('LIFX light setLabel method expects a minimum of one char as label');\n  }\n  if (callback !== undefined && typeof callback !== 'function') {\n    throw new TypeError('LIFX light setLabel method expects callback to be a function');\n  }\n\n  var packetObj = packet.create('setLabel', {label: label}, this.client.source);\n  packetObj.target = this.id;\n  this.client.send(packetObj, callback);\n};\n\n/**\n * Requests ambient light value of the light\n * @param {Function} callback a function to accept the data\n */\nLight.prototype.getAmbientLight = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getAmbientLight method expects callback to be a function');\n  }\n  var packetObj = packet.create('getAmbientLight', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('stateAmbientLight', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    return callback(null, msg.flux);\n  }, sqnNumber);\n};\n\n/**\n * Requests the power level of the light\n * @param {Function} callback a function to accept the data\n */\nLight.prototype.getPower = function(callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX light getPower method expects callback to be a function');\n  }\n  var packetObj = packet.create('getPower', {}, this.client.source);\n  packetObj.target = this.id;\n  var sqnNumber = this.client.send(packetObj);\n  this.client.addMessageHandler('statePower', function(err, msg) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (msg.level === 65535) {\n      msg.level = 1;\n    }\n    return callback(null, msg.level);\n  }, sqnNumber);\n};\n\nexports.Light = Light;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/lib/lifx/client.js":"'use strict';\n\nvar util = require('util');\nvar dgram = require('dgram');\nvar EventEmitter = require('eventemitter3');\nvar _ = require('lodash');\nvar Packet = require('../lifx').packet;\nvar Light = require('../lifx').Light;\nvar constants = require('../lifx').constants;\nvar utils = require('../lifx').utils;\n\n/**\n * Creates a lifx client\n * @extends EventEmitter\n */\nfunction Client() {\n  EventEmitter.call(this);\n\n  this.debug = false;\n  this.socket = dgram.createSocket('udp4');\n  this.isSocketBound = false;\n  this.devices = {};\n  this.port = null;\n  this.messagesQueue = [];\n  this.sendTimer = null;\n  this.discoveryTimer = null;\n  this.discoveryPacketSequence = 0;\n  this.messageHandlers = [{\n    type: 'stateService',\n    callback: this.processDiscoveryPacket.bind(this)\n  }, {\n    type: 'stateLabel',\n    callback: this.processLabelPacket.bind(this)\n  }, {\n    type: 'stateLight',\n    callback: this.processLabelPacket.bind(this)\n  }];\n  this.sequenceNumber = 0;\n  this.lightOfflineTolerance = 3;\n  this.messageHandlerTimeout = 45000; // 45 sec\n  this.resendPacketDelay = 150;\n  this.resendMaxTimes = 5;\n  this.source = utils.getRandomHexString(8);\n  this.broadcastAddress = '255.255.255.255';\n}\nutil.inherits(Client, EventEmitter);\n\n/**\n * Creates a new socket and starts discovery\n * @example\n * init({debug: true}, function() {\n *   console.log('Client started');\n * })\n * @param {Object} [options] Configuration to use\n * @param {String} [options.address] The IPv4 address to bind to\n * @param {Number} [options.port] The port to bind to\n * @param {Boolean} [options.debug] Show debug output\n * @param {Number} [options.lightOfflineTolerance] If light hasn't answered for amount of discoveries it is set offline\n * @param {Number} [options.messageHandlerTimeout] Message handlers not called will be removed after this delay in ms\n * @param {String} [options.source] The source to send to light, must be 8 chars lowercase or digit\n * @param {Boolean} [options.startDiscovery] Weather to start discovery after initialization or not\n * @param {Array} [options.lights] Pre set list of ip addresses of known addressable lights\n * @param {String} [options.broadcast] The broadcast address to use for light discovery\n * @param {Function} [callback] Called after initialation\n */\nClient.prototype.init = function(options, callback) {\n  var defaults = {\n    address: '0.0.0.0',\n    port: constants.LIFX_DEFAULT_PORT,\n    debug: false,\n    lightOfflineTolerance: 3,\n    messageHandlerTimeout: 45000,\n    source: '',\n    startDiscovery: true,\n    lights: [],\n    broadcast: '255.255.255.255',\n    resendPacketDelay: 150,\n    resendMaxTimes: 3\n  };\n\n  options = options || {};\n  var opts = _.defaults(options, defaults);\n\n  if (typeof opts.port !== 'number') {\n    throw new TypeError('LIFX Client port option must be a number');\n  } else if (opts.port > 65535 || opts.port < 1) {\n    throw new RangeError('LIFX Client port option must be between 1 and 65535');\n  }\n\n  if (typeof opts.debug !== 'boolean') {\n    throw new TypeError('LIFX Client debug option must be a boolean');\n  }\n  this.debug = opts.debug;\n\n  if (typeof opts.lightOfflineTolerance !== 'number') {\n    throw new TypeError('LIFX Client lightOfflineTolerance option must be a number');\n  }\n  this.lightOfflineTolerance = opts.lightOfflineTolerance;\n\n  if (typeof opts.messageHandlerTimeout !== 'number') {\n    throw new TypeError('LIFX Client messageHandlerTimeout option must be a number');\n  }\n  this.messageHandlerTimeout = opts.messageHandlerTimeout;\n\n  if (typeof opts.resendPacketDelay !== 'number') {\n    throw new TypeError('LIFX Client resendPacketDelay option must be a number');\n  }\n  this.resendPacketDelay = opts.resendPacketDelay;\n\n  if (typeof opts.resendMaxTimes !== 'number') {\n    throw new TypeError('LIFX Client resendMaxTimes option must be a number');\n  }\n  this.resendMaxTimes = opts.resendMaxTimes;\n\n  if (typeof opts.broadcast !== 'string') {\n    throw new TypeError('LIFX Client broadcast option must be a string');\n  } else if (!utils.isIpv4Format(opts.broadcast)) {\n    throw new TypeError('LIFX Client broadcast option does only allow IPv4 address format');\n  }\n  this.broadcastAddress = opts.broadcast;\n\n  if (!_.isArray(opts.lights)) {\n    throw new TypeError('LIFX Client lights option must be an array');\n  } else {\n    opts.lights.forEach(function(light) {\n      if (!utils.isIpv4Format(light)) {\n        throw new TypeError('LIFX Client lights option array element \\'' + light + '\\' is not expected IPv4 format');\n      }\n    });\n  }\n\n  if (opts.source !== '') {\n    if (typeof opts.source === 'string') {\n      if (/^[0-9A-F]{8}$/.test(opts.source)) {\n        this.source = opts.source;\n      } else {\n        throw new RangeError('LIFX Client source option must be 8 hex chars');\n      }\n    } else {\n      throw new TypeError('LIFX Client source option must be given as string');\n    }\n  }\n\n  this.socket.on('error', function(err) {\n    this.isSocketBound = false;\n    console.error('LIFX Client UDP error');\n    console.trace(err);\n    this.socket.close();\n    this.emit('error', err);\n  }.bind(this));\n\n  this.socket.on('message', function(msg, rinfo) {\n    // Ignore own messages and false formats\n    if (utils.getHostIPs().indexOf(rinfo.address) >= 0 || !Buffer.isBuffer(msg)) {\n      return;\n    }\n\n    /* istanbul ignore if  */\n    if (this.debug) {\n      console.log('DEBUG - ' + msg.toString('hex') + ' from ' + rinfo.address);\n    }\n\n    // Parse packet to object\n    var parsedMsg = Packet.toObject(msg);\n\n    // Check if packet is read successfully\n    if (parsedMsg instanceof Error) {\n      console.error('LIFX Client invalid packet header error');\n      console.error('Packet: ', msg.toString('hex'));\n      console.trace(parsedMsg);\n    } else {\n      // Convert type before emitting\n      var messageTypeName = _.result(_.find(Packet.typeList, {id: parsedMsg.type}), 'name');\n      if (messageTypeName !== undefined) {\n        parsedMsg.type = messageTypeName;\n      }\n      // Check for handlers of given message and rinfo\n      this.processMessageHandlers(parsedMsg, rinfo);\n\n      this.emit('message', parsedMsg, rinfo);\n    }\n  }.bind(this));\n\n  this.socket.bind(opts.port, opts.address, function() {\n    this.isSocketBound = true;\n    this.socket.setBroadcast(true);\n    this.emit('listening');\n    this.port = opts.port;\n\n    // Start scanning\n    if (opts.startDiscovery) {\n      this.startDiscovery(opts.lights);\n    }\n    if (typeof callback === 'function') {\n      return callback();\n    }\n  }.bind(this));\n};\n\n/**\n * Destroy an instance\n */\nClient.prototype.destroy = function() {\n  this.stopDiscovery();\n  this.stopSendingProcess();\n  if (this.isSocketBound) {\n    this.socket.close();\n  }\n};\n\n/**\n * Sends a packet from the messages queue or stops the sending process\n * if queue is empty\n **/\nClient.prototype.sendingProcess = function() {\n  if (!this.isSocketBound) {\n    this.stopSendingProcess();\n    console.log('LIFX Client stopped sending due to unbound socket');\n    return;\n  }\n\n  if (this.messagesQueue.length > 0) {\n    var msg = this.messagesQueue.pop();\n    if (msg.address === undefined) {\n      msg.address = this.broadcastAddress;\n    }\n    if (msg.transactionType === constants.PACKET_TRANSACTION_TYPES.ONE_WAY) {\n      this.socket.send(msg.data, 0, msg.data.length, this.port, msg.address);\n      /* istanbul ignore if  */\n      if (this.debug) {\n        console.log('DEBUG - ' + msg.data.toString('hex') + ' to ' + msg.address);\n      }\n    } else if (msg.transactionType === constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE) {\n      if (msg.timesSent < this.resendMaxTimes) {\n        if (Date.now() > (msg.timeLastSent + this.resendPacketDelay)) {\n          this.socket.send(msg.data, 0, msg.data.length, this.port, msg.address);\n          msg.timesSent += 1;\n          msg.timeLastSent = Date.now();\n          /* istanbul ignore if  */\n          if (this.debug) {\n            console.log(\n              'DEBUG - ' + msg.data.toString('hex') + ' to ' + msg.address +\n              ', send ' + msg.timesSent + ' time(s)'\n            );\n          }\n        }\n        // Add to the end of the queue again\n        this.messagesQueue.unshift(msg);\n      } else {\n        this.messageHandlers.forEach(function(handler, hdlrIndex) {\n          if (handler.type === 'acknowledgement' && handler.sequenceNumber === msg.sequence) {\n            this.messageHandlers.splice(hdlrIndex, 1);\n            var err = new Error('No LIFX response after max resend limit of ' + this.resendMaxTimes);\n            return handler.callback(err, null, null);\n          }\n        }.bind(this));\n      }\n    }\n  } else {\n    this.stopSendingProcess();\n  }\n};\n\n/**\n * Starts the sending of all packages in the queue\n */\nClient.prototype.startSendingProcess = function() {\n  if (this.sendTimer === null) { // Already running?\n    this.sendTimer = setInterval(this.sendingProcess.bind(this), constants.MESSAGE_RATE_LIMIT);\n  }\n};\n\n/**\n * Stops sending of all packages in the queue\n */\nClient.prototype.stopSendingProcess = function() {\n  if (this.sendTimer !== null) {\n    clearInterval(this.sendTimer);\n    this.sendTimer = null;\n  }\n};\n\n/**\n * Start discovery of lights\n * This will keep the list of lights updated, finds new lights and sets lights\n * offline if no longer found\n * @param {Array} [lights] Pre set list of ip addresses of known addressable lights to request directly\n */\nClient.prototype.startDiscovery = function(lights) {\n  lights = lights || [];\n  var sendDiscoveryPacket = function() {\n    // Sign flag on inactive lights\n    _.forEach(this.devices, _.bind(function(info, deviceId) {\n      if (this.devices[deviceId].status !== 'off') {\n        var diff = this.discoveryPacketSequence - info.seenOnDiscovery;\n        if (diff >= this.lightOfflineTolerance) {\n          this.devices[deviceId].status = 'off';\n          this.emit('bulb-offline', info); // deprecated\n          this.emit('light-offline', info);\n        }\n      }\n    }, this));\n\n    // Send a discovery packet broadcast\n    this.send(Packet.create('getService', {}, this.source));\n\n    // Send a discovery packet to each light given directly\n    lights.forEach(function(lightAddress) {\n      var msg = Packet.create('getService', {}, this.source);\n      msg.address = lightAddress;\n      this.send(msg);\n    }, this);\n\n    // Keep track of a sequent number to find not answering lights\n    if (this.discoveryPacketSequence >= Number.MAX_VALUE) {\n      this.discoveryPacketSequence = 0;\n    } else {\n      this.discoveryPacketSequence += 1;\n    }\n  }.bind(this);\n\n  this.discoveryTimer = setInterval(\n    sendDiscoveryPacket,\n    constants.DISCOVERY_INTERVAL\n  );\n\n  sendDiscoveryPacket();\n};\n\n/**\n * Checks all registered message handlers if they request the given message\n * @param  {Object} msg message to check handler for\n * @param  {Object} rinfo rinfo address info to check handler for\n */\nClient.prototype.processMessageHandlers = function(msg, rinfo) {\n  // Process only packages for us\n  if (msg.source.toLowerCase() !== this.source.toLowerCase()) {\n    return;\n  }\n  // We check our message handler if the answer received is requested\n  this.messageHandlers.forEach(function(handler, hdlrIndex) {\n    if (msg.type === handler.type) {\n      if (handler.sequenceNumber !== undefined) {\n        if (handler.sequenceNumber === msg.sequence) {\n          // Remove if specific packet was request, since it should only be called once\n          this.messageHandlers.splice(hdlrIndex, 1);\n          this.messagesQueue.forEach(function(packet, packetIndex) {\n            if (packet.transactionType === constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE &&\n                packet.sequence === msg.sequence) {\n              this.messagesQueue.splice(packetIndex, 1);\n            }\n          }.bind(this));\n\n          // Call the function requesting the packet\n          return handler.callback(null, msg, rinfo);\n        }\n      } else {\n        // Call the function requesting the packet\n        return handler.callback(null, msg, rinfo);\n      }\n    }\n\n    // We want to call expired request handlers for specific packages after the\n    // messageHandlerTimeout set in options, to specify an error\n    if (handler.sequenceNumber !== undefined) {\n      if (Date.now() > (handler.timestamp + this.messageHandlerTimeout)) {\n        this.messageHandlers.splice(hdlrIndex, 1);\n\n        var err = new Error('No LIFX response in time');\n        return handler.callback(err, null, null);\n      }\n    }\n  }, this);\n};\n\n/**\n * Processes a discovery report packet to update internals\n * @param  {Object} err Error if existant\n * @param  {Object} msg The discovery report package\n * @param  {Object} rinfo Remote host details\n */\nClient.prototype.processDiscoveryPacket = function(err, msg, rinfo) {\n  if (err) {\n    return;\n  }\n  if (msg.service === 'udp' && msg.port === constants.LIFX_DEFAULT_PORT) {\n    // Add / update the found gateway\n    if (!this.devices[msg.target]) {\n      var lightDevice = new Light({\n        client: this,\n        id: msg.target,\n        address: rinfo.address,\n        port: msg.port,\n        seenOnDiscovery: this.discoveryPacketSequence\n      });\n      this.devices[msg.target] = lightDevice;\n\n      // Request label\n      var labelRequest = Packet.create('getLabel', {}, this.source);\n      labelRequest.target = msg.target;\n      this.send(labelRequest);\n\n      this.emit('bulb-new', lightDevice); // deprecated\n      this.emit('light-new', lightDevice);\n    } else {\n      if (this.devices[msg.target].status === 'off') {\n        this.devices[msg.target].status = 'on';\n        this.emit('bulb-online', this.devices[msg.target]); // deprecated\n        this.emit('light-online', this.devices[msg.target]);\n      }\n      this.devices[msg.target].address = rinfo.address;\n      this.devices[msg.target].seenOnDiscovery = this.discoveryPacketSequence;\n    }\n  }\n};\n\n/**\n * Processes a state label packet to update internals\n * @param {Object} err Error if existant\n * @param {Object} msg The state label package\n */\nClient.prototype.processLabelPacket = function(err, msg) {\n  if (err) {\n    return;\n  }\n  if (this.devices[msg.target] !== undefined) {\n    this.devices[msg.target].label = msg.label;\n  }\n};\n\n/**\n * This stops the discovery process\n * The client will be no longer updating the state of lights or find lights\n */\nClient.prototype.stopDiscovery = function() {\n  clearInterval(this.discoveryTimer);\n  this.discoveryTimer = null;\n};\n\n/**\n * Send a LIFX message objects over the network\n * @param  {Object} msg A message object or multiple with data to send\n * @param  {Function} [callback] Function to handle error and success after send\n * @return {Number} The sequence number of the request\n */\nClient.prototype.send = function(msg, callback) {\n  var packet = {\n    timeCreated: Date.now(),\n    timeLastSent: 0,\n    timesSent: 0,\n    transactionType: constants.PACKET_TRANSACTION_TYPES.ONE_WAY\n  };\n\n  // Add the target ip address if target given\n  if (msg.address !== undefined) {\n    packet.address = msg.address;\n  }\n  if (msg.target !== undefined) {\n    var targetBulb = this.light(msg.target);\n    if (targetBulb) {\n      packet.address = targetBulb.address;\n      // If we would exceed the max value for the int8 field start over again\n      if (this.sequenceNumber >= constants.PACKET_HEADER_SEQUENCE_MAX) {\n        this.sequenceNumber = 0;\n      } else {\n        this.sequenceNumber += 1;\n      }\n    }\n  }\n\n  msg.sequence = this.sequenceNumber;\n  packet.sequence = this.sequenceNumber;\n  if (typeof callback === 'function') {\n    msg.ackRequired = true;\n    this.addMessageHandler('acknowledgement', callback, msg.sequence);\n    packet.transactionType = constants.PACKET_TRANSACTION_TYPES.REQUEST_RESPONSE;\n  }\n  packet.data = Packet.toBuffer(msg);\n  this.messagesQueue.unshift(packet);\n  this.startSendingProcess();\n\n  return this.sequenceNumber;\n};\n\n/**\n * Get network address data from connection\n * @return {Object} Network address data\n */\nClient.prototype.address = function() {\n  var address = null;\n  try {\n    address = this.socket.address();\n  } catch (e) {}\n  return address;\n};\n\n/**\n * Sets debug on or off at runtime\n * @param  {boolean} debug debug messages on\n */\nClient.prototype.setDebug = function(debug) {\n  if (typeof debug !== 'boolean') {\n    throw new TypeError('LIFX Client setDebug expects boolean as parameter');\n  }\n  this.debug = debug;\n};\n\n/**\n * Adds a message handler that calls a function when the requested\n * info was received\n * @param {String} type A type of packet to listen for, like stateLight\n * @param {Function} callback the function to call if the packet was received,\n *                   this will be called with parameters msg and rinfo\n * @param {Number} [sequenceNumber] Expects a specific sequenceNumber on which will\n *                                  be called, this will call it only once. If not\n *                                  given the callback handler is permanent\n */\nClient.prototype.addMessageHandler = function(type, callback, sequenceNumber) {\n  if (typeof type !== 'string') {\n    throw new TypeError('LIFX Client addMessageHandler expects type parameter to be string');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError('LIFX Client addMessageHandler expects callback parameter to be a function');\n  }\n\n  var typeName = _.find(Packet.typeList, {name: type});\n  if (typeName === undefined) {\n    throw new RangeError('LIFX Client addMessageHandler unknown packet type: ' + type);\n  }\n\n  var handler = {\n    type: type,\n    callback: callback.bind(this),\n    timestamp: Date.now()\n  };\n\n  if (sequenceNumber !== undefined) {\n    if (typeof sequenceNumber !== 'number') {\n      throw new TypeError('LIFX Client addMessageHandler expects sequenceNumber to be a integer');\n    } else {\n      handler.sequenceNumber = sequenceNumber;\n    }\n  }\n\n  this.messageHandlers.push(handler);\n};\n\n/**\n * Returns the list of all known lights\n * @example client.lights()\n * @param {String} [status='on'] Status to filter for, empty string for all\n * @return {Array} Lights\n */\nClient.prototype.lights = function(status) {\n  if (status === undefined) {\n    status = 'on';\n  } else if (typeof status !== 'string') {\n    throw new TypeError('LIFX Client lights expects status to be a string');\n  }\n\n  if (status.length > 0) {\n    if (status !== 'on' && status !== 'off') {\n      throw new TypeError('Lifx Client lights expects status to be \\'on\\', \\'off\\' or \\'\\'');\n    }\n\n    var result = [];\n    _.forEach(this.devices, function(light) {\n      if (light.status === status) {\n        result.push(light);\n      }\n    });\n    return result;\n  }\n\n  return this.devices;\n};\n\n/**\n * Find a light by label, id or ip\n * @param {String} identifier label, id or ip to search for\n * @return {Object|Boolean} the light object or false if not found\n */\nClient.prototype.light = function(identifier) {\n  var result;\n  if (typeof identifier !== 'string') {\n    throw new TypeError('LIFX Client light expects identifier for LIFX light to be a string');\n  }\n\n  // There is no ip or id longer than 45 chars, no label longer than 32 bit\n  if (identifier.length > 45 && Buffer.byteLength(identifier, 'utf8') > 32) {\n    return false;\n  }\n\n  // Dots or colons is high likely an ip\n  if (identifier.indexOf('.') >= 0 || identifier.indexOf(':') >= 0) {\n    result = _.find(this.devices, {address: identifier}) || false;\n    if (result !== false) {\n      return result;\n    }\n  }\n\n  // Search id\n  result = _.find(this.devices, {id: identifier}) || false;\n  if (result !== false) {\n    return result;\n  }\n\n  // Search label\n  result = _.find(this.devices, {label: identifier}) || false;\n\n  return result;\n};\n\nexports.Client = Client;\n","/home/travis/build/npmtest/node-npmtest-node-lifx/node_modules/node-lifx/babelhook.js":"// This file is required in mocha.opts\n// The only purpose of this file is to ensure\n// the babel transpiler is activated prior to any\n// test code, and using the same babel options\n\nrequire('babel-core/register')({\n  // Only compile test files\n  only: /-test.js$/,\n  presets: ['es2015']\n});\n"}